<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8"/>
<title>HTTP Proxy 工具 (MUI版 - 已修复)</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>

<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>

<script type="text/babel" data-type="module">
	import {
		Add, ContentCopy, Delete, FileUpload,
	} from 'https://esm.sh/@mui/icons-material?standalone';
	import {
		Box, Button, Checkbox, CircularProgress, Container, FormControl, FormControlLabel, InputLabel, MenuItem, Paper,
		Select, Stack, Tab, Tabs, TextField, Typography,
	} from 'https://esm.sh/@mui/material?standalone';
	import React, {useCallback, useEffect, useState} from 'https://esm.sh/react';
	import {createRoot} from 'https://esm.sh/react-dom/client?standalone';

	// ==================================
	// 主应用组件
	// ==================================
	function App(){
		// --- 状态管理 (与原版完全相同) ---
		const [method, setMethod] = useState('GET');
		const [url, setUrl] = useState('');
		const [headers, setHeaders] = useState([]);
		const [bodyType, setBodyType] = useState('none');
		const [jsonBody, setJsonBody] = useState('');
		const [formBody, setFormBody] = useState([]);
		const [multipartBody, setMultipartBody] = useState([]);
		const [binaryFile, setBinaryFile] = useState(null);
		const [response, setResponse] = useState('');
		const [isLoading, setIsLoading] = useState(false);
		const [manualRedirect, setManualRedirect] = useState(false);
		const [useProxy, setUseProxy] = useState(true);
		const [copyInfo, setCopyInfo] = useState({message:'', anchor:null}); // *** BUG修复：状态升级
		const [selectedExample, setSelectedExample] = useState('');

		// --- 数据和工具函数 (与原版完全相同) ---
		const exampleRequests = [
			{
				name:'GET 示例 (httpbin.org/get)',
				method:'GET',
				url:'https://httpbin.org/get',
				headers:[{name:'Accept', value:'application/json'}],
				bodyType:'none', jsonBody:'', formBody:[], multipartBody:[], binaryFile:null,
			},
			{
				name:'JSON POST 示例 (httpbin.org/post)',
				method:'POST',
				url:'https://httpbin.org/post',
				headers:[{name:'X-Custom-Header', value:'ReactProxyTest'}],
				bodyType:'json',
				jsonBody:JSON.stringify({query:'React Proxy', items:[{id:1, name:'item1'}, {id:2, name:'item2'}]}, null, 2),
				formBody:[], multipartBody:[], binaryFile:null,
			},
			{
				name:'Form POST 示例 (httpbin.org/post)',
				method:'POST',
				url:'https://httpbin.org/post',
				headers:[],
				bodyType:'form',
				formBody:[{name:'username', value:'testUser'}, {name:'action', value:'submit'}],
				jsonBody:'', multipartBody:[], binaryFile:null,
			},
			{
				name:'Multipart POST 示例 (httpbin.org/post)',
				method:'POST',
				url:'https://httpbin.org/post',
				headers:[],
				bodyType:'multipart',
				multipartBody:[
					{name:'textParam', value:'Hello Multipart', type:'text', file:null},
					{name:'fileParam', value:'', type:'file', file:null},
				],
				jsonBody:'', formBody:[], binaryFile:null,
			},
			{
				name:'Binary File POST 示例 (httpbin.org/post)',
				method:'POST',
				url:'https://httpbin.org/post',
				headers:[],
				bodyType:'binary',
				binaryFile:null,
				jsonBody:'', formBody:[], multipartBody:[],
			},
			{
				name:'手动重定向 GET 示例 (httpbin.org/redirect-to)',
				method:'GET',
				url:'https://httpbin.org/redirect-to?url=https://example.com',
				headers:[],
				bodyType:'none',
				jsonBody:'', formBody:[], multipartBody:[], binaryFile:null,
				manualRedirect:true,
			},
		];

		const genId = ()=>Date.now()+Math.random();

		const loadExample = useCallback((exampleName)=>{
			const example = exampleRequests.find(ex=>ex.name===exampleName);
			if (!example){ return; }
			setSelectedExample(exampleName);
			const {
				method = 'GET', url = '', headers = [], bodyType = 'none',
				jsonBody = '', formBody = [], multipartBody = [], manualRedirect = false,
			} = example;
			setMethod(method);
			setUrl(url);
			setHeaders(headers.map(h=>({...h, id:genId()})));
			setBodyType(bodyType);
			setJsonBody(jsonBody);
			setFormBody(formBody.map(f=>({...f, id:genId()})));
			setMultipartBody(multipartBody.map(m=>({...m, id:genId(), file:null})));
			setBinaryFile(null);
			setManualRedirect(manualRedirect);
			setResponse('示例已加载。配置完成后，请点击“发送请求”。');
		}, []);

		useEffect(()=>{ loadExample(exampleRequests[0].name); }, []);

		// --- 业务逻辑函数 (handleCopyAsFetch 已修改) ---
		const handleCopyAsFetch = async(useProxyForCopy)=>{
			const requestHeaders = new Headers();
			let hasUserContentType = false;
			headers.forEach(h=>{
				if (h.name && h.value){
					requestHeaders.set(h.name, h.value);
					if (h.name.toLowerCase()==='content-type'){ hasUserContentType = true; }
				}
			});
			let autoContentType = null;
			let bodySetupCode = '';
			let bodyInlinedCode = null;
			if (method!=='GET' && method!=='HEAD'){
				switch (bodyType){
					case 'json':
						autoContentType = 'application/json; charset=utf-8';
						bodyInlinedCode = `JSON.stringify(${jsonBody})`;
						break;
					case 'form':
						const paramsArray = [];
						formBody.forEach(p=>{ if (p.name){ paramsArray.push([p.name, p.value]); } });
						autoContentType = 'application/x-www-form-urlencoded; charset=utf-8';
						bodyInlinedCode = `new URLSearchParams(${JSON.stringify(paramsArray)})`;
						break;
					case 'multipart':
						bodySetupCode = `const formData = new FormData();\n`;
						multipartBody.forEach(p=>{
							if (p.name){
								const paramName = p.name.replaceAll('\'', '\\\'');
								if (p.type==='file'){
									bodySetupCode += `// TODO: You need to provide the actual file content for '${paramName}'.\n`;
									bodySetupCode += `formData.append('${paramName}', new File(['file content'], 'filename', {type: 'filetype'}));\n`;
								} else {
									const paramValue = p.value.replaceAll('\'', '\\\'');
									bodySetupCode += `formData.append('${paramName}', '${paramValue}');\n`;
								}
							}
						});
						bodyInlinedCode = 'formData';
						break;
					case 'binary':
						bodySetupCode = `// TODO: You need to provide the file blob or buffer for the body.\n`;
						bodySetupCode += `const bodyBlob = new Blob(['file content'], {type: 'application/octet-stream'});\n`;
						bodyInlinedCode = 'bodyBlob';
						break;
				}
			}
			let fetchUrl;
			let fetchOptions;
			const headersObject = {};
			if (autoContentType && !hasUserContentType){ requestHeaders.set('Content-Type', autoContentType); }
			requestHeaders.forEach((value, key)=>{ headersObject[key] = value; });
			if (useProxyForCopy){
				fetchUrl = `${window.location.origin}/api/proxy`;
				const proxyHeaders = {...headersObject};
				proxyHeaders['X-Url'] = url;
				proxyHeaders['X-Method'] = method;
				if (manualRedirect){ proxyHeaders['X-Redirect'] = 'manual'; }
				fetchOptions = {method:'POST', headers:proxyHeaders};
			} else {
				fetchUrl = url;
				fetchOptions = {method:method};
				if (Object.keys(headersObject).length>0){ fetchOptions.headers = headersObject; }
				if (manualRedirect){ fetchOptions.redirect = 'manual'; }
			}
			if (bodyInlinedCode){ fetchOptions.body = `%BODY_PLACEHOLDER%`; }
			let optionsString = JSON.stringify(fetchOptions, null, 2).replace('"%BODY_PLACEHOLDER%"', bodyInlinedCode);
			const fetchCode = `${bodySetupCode? bodySetupCode+'\n': ''}fetch('${fetchUrl}', ${optionsString});`;
			// *** BUG修复：设置带有来源的提示信息
			try {
				await navigator.clipboard.writeText(fetchCode);
				setCopyInfo({message:'已复制!', anchor:useProxyForCopy? 'proxy': 'direct'});
				setTimeout(()=>setCopyInfo({message:'', anchor:null}), 2000);
			} catch (err){
				console.error('Failed to copy: ', err);
				setCopyInfo({message:'复制失败!', anchor:useProxyForCopy? 'proxy': 'direct'});
				setTimeout(()=>setCopyInfo({message:'', anchor:null}), 2000);
			}
		};
		const handleSendRequest = async()=>{
			setIsLoading(true);
			setResponse('请求中...');
			if (!url){
				setResponse('错误: 目标 URL 不能为空。');
				setIsLoading(false);
				return;
			}
			const requestHeaders = new Headers();
			let hasUserContentType = false;
			headers.forEach(h=>{
				if (h.name && h.value){
					requestHeaders.set(h.name, h.value);
					if (h.name.toLowerCase()==='content-type'){ hasUserContentType = true; }
				}
			});
			let bodyToSend = null;
			let autoContentType = null;
			if (method!=='GET' && method!=='HEAD'){
				switch (bodyType){
					case 'json':
						bodyToSend = jsonBody;
						autoContentType = 'application/json; charset=utf-8';
						break;
					case 'form':
						const params = new URLSearchParams();
						formBody.forEach(p=>{ if (p.name){ params.append(p.name, p.value); } });
						bodyToSend = params;
						autoContentType = 'application/x-www-form-urlencoded; charset=utf-8';
						break;
					case 'multipart':
						const formData = new FormData();
						multipartBody.forEach(p=>{
							if (p.name){
								if (p.type==='file' && p.file){
									formData.append(p.name, p.file, p.file.name);
								} else if (p.type==='text'){
									formData.append(p.name, p.value);
								}
							}
						});
						bodyToSend = formData;
						autoContentType = null;
						break;
					case 'binary':
						bodyToSend = binaryFile;
						if (binaryFile){ autoContentType = binaryFile.type || 'application/octet-stream'; }
						break;
					default:
						bodyToSend = null;
						break;
				}
			}
			if (autoContentType && !hasUserContentType){ requestHeaders.set('Content-Type', autoContentType); }
			if (bodyToSend instanceof FormData && hasUserContentType){
				requestHeaders.delete(headers.find(h=>h.name.toLowerCase()==='content-type').name);
			}
			try {
				let fetchUrl;
				let fetchOptions;
				if (useProxy){
					const proxyHeaders = new Headers();
					proxyHeaders.set('X-Url', url);
					proxyHeaders.set('X-Method', method);
					if (manualRedirect){ proxyHeaders.set('X-Redirect', 'manual'); }
					requestHeaders.forEach((value, key)=>{ proxyHeaders.set(key, value); });
					fetchUrl = '/api/proxy';
					fetchOptions = {method:'POST', headers:proxyHeaders, body:bodyToSend, redirect:'manual'};
				} else {
					fetchUrl = url;
					fetchOptions = {method:method, headers:requestHeaders, body:bodyToSend, redirect:manualRedirect? 'manual': 'follow'};
				}
				const res = await fetch(fetchUrl, fetchOptions);
				const responseHeaders = {};
				res.headers.forEach((value, key)=>{ responseHeaders[key] = value; });
				let responseBodyContent;
				const respContentType = res.headers.get('content-type');
				if (respContentType?.includes('application/json')){
					responseBodyContent = await res.json();
				} else if (respContentType?.includes('text/') || respContentType?.includes('application/xml')
						|| respContentType?.includes('application/javascript')){
					responseBodyContent = await res.text();
				} else if (res.body){
					try {
						const blob = await res.blob();
						responseBodyContent = `[Binary data: ${blob.size} bytes, Type: ${blob.type || 'unknown'}]`;
					} catch (e){
						responseBodyContent = '[Response body exists but could not be read]';
					}
				} else {
					responseBodyContent = '[No response body]';
				}
				const result = {status:res.status, statusText:res.statusText, headers:responseHeaders, body:responseBodyContent};
				setResponse(JSON.stringify(result, null, 2));
			} catch (err){
				let errorMessage = '请求失败:\n'+(err.message || String(err));
				if (!useProxy && err.name==='TypeError' && err.message.includes('Failed to fetch')){
					errorMessage += '\n\n提示：当不使用代理直接请求时，可能会遇到 CORS 跨域问题。';
				}
				setResponse(errorMessage);
			} finally {
				setIsLoading(false);
			}
		};

		// --- UI 渲染 ---
		return (
				<Container maxWidth="md" className="py-8">
					<Stack spacing={4}>
						<Typography variant="h4" component="h1" className="text-center font-bold text-indigo-700">
							HTTP 代理工具
						</Typography>
						<Paper elevation={2} className="p-4">
							<FormControl fullWidth>
								<InputLabel>加载预设示例</InputLabel>
								<Select value={selectedExample} label="加载预设示例" onChange={(e)=>loadExample(e.target.value)}>
									{exampleRequests.map(ex=>(<MenuItem key={ex.name} value={ex.name}>{ex.name}</MenuItem>))}
								</Select>
							</FormControl>
						</Paper>
						<Paper elevation={2} className="p-4">
							<Stack spacing={4}>
								<Stack direction="row" spacing={2}>
									<FormControlLabel control={<Checkbox checked={useProxy} onChange={e=>setUseProxy(e.target.checked)}/>}
																		label="使用代理 (推荐)"/>
									<FormControlLabel control={<Checkbox checked={manualRedirect} onChange={e=>setManualRedirect(e.target.checked)}/>}
																		label="手动处理重定向"/>
								</Stack>
								<RequestUrlBar method={method} setMethod={setMethod} url={url} setUrl={setUrl}/>
								<HeadersEditor headers={headers} setHeaders={setHeaders} genId={genId}/>
								<BodyEditor
										bodyType={bodyType} setBodyType={setBodyType}
										jsonBody={jsonBody} setJsonBody={setJsonBody}
										formBody={formBody} setFormBody={setFormBody}
										multipartBody={multipartBody} setMultipartBody={setMultipartBody}
										binaryFile={binaryFile} setBinaryFile={setBinaryFile}
										genId={genId}
								/>
								<ActionButtons
										isLoading={isLoading}
										handleSendRequest={handleSendRequest}
										handleCopyAsFetch={handleCopyAsFetch}
										copyInfo={copyInfo}
								/>
							</Stack>
						</Paper>
						<Box>
							<Typography variant="h5" component="h2" className="mb-2 font-semibold">响应结果:</Typography>
							<Paper variant="outlined" className="bg-gray-900">
								<pre
										className="text-green-300 p-4 overflow-x-auto text-sm whitespace-pre-wrap break-all font-mono">
									{response}
								</pre>
							</Paper>
						</Box>
						<Typography variant="body2" className="text-center text-gray-500 mt-8">
							HTTP Proxy 工具 (MUI 版)
						</Typography>
					</Stack>
				</Container>
		);
	}

	// ==================================
	// 子组件 (ActionButtons 已修改)
	// ==================================
	function RequestUrlBar({method, setMethod, url, setUrl}){
		return (
				<Stack direction="row" spacing={1} alignItems="center">
					<FormControl size="small" sx={{minWidth:120}}>
						<InputLabel>Method</InputLabel>
						<Select value={method} label="Method" onChange={e=>setMethod(e.target.value)}>
							{['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS', 'HEAD'].map(m=><MenuItem key={m} value={m}>{m}</MenuItem>)}
						</Select>
					</FormControl>
					<TextField
							fullWidth size="small" label="目标 URL"
							value={url} onChange={e=>setUrl(e.target.value)}
							placeholder="例如: https://api.example.com/data"
					/>
				</Stack>
		);
	}

	function HeadersEditor({headers, setHeaders, genId}){
		const addHeader = ()=>setHeaders([...headers, {id:genId(), name:'', value:''}]);
		const removeHeader = (id)=>setHeaders(headers.filter(h=>h.id!==id));
		const updateHeader = (id, field, value)=>{
			setHeaders(headers.map(h=>h.id===id? {...h, [field]:value}: h));
		};
		return (
				<Stack spacing={2}>
					<Typography variant="h6">请求 Headers</Typography>
					{headers.map((header)=>(
							<Stack key={header.id} direction="row" spacing={1} alignItems="center">
								<TextField size="small" label="Name" value={header.name}
													 onChange={e=>updateHeader(header.id, 'name', e.target.value)} className="flex-1"/>
								<TextField size="small" label="Value" value={header.value}
													 onChange={e=>updateHeader(header.id, 'value', e.target.value)} className="flex-1"/>
								<Button size="small" color="error" onClick={()=>removeHeader(header.id)} startIcon={<Delete/>}>删除</Button>
							</Stack>
					))}
					<Box><Button variant="outlined" size="small" onClick={addHeader} startIcon={<Add/>}>添加 Header</Button></Box>
				</Stack>
		);
	}

	function BodyEditor(props){
		const {
			bodyType, setBodyType, jsonBody, setJsonBody, formBody, setFormBody,
			multipartBody, setMultipartBody, binaryFile, setBinaryFile, genId,
		} = props;
		const addFormParam = ()=>setFormBody([...formBody, {id:genId(), name:'', value:''}]);
		const removeFormParam = (id)=>setFormBody(formBody.filter(p=>p.id!==id));
		const updateFormParam = (id, field, value)=>{ setFormBody(formBody.map(p=>p.id===id? {...p, [field]:value}: p)); };
		const addMultipartParam = ()=>setMultipartBody([...multipartBody, {id:genId(), name:'', value:'', type:'text', file:null}]);
		const removeMultipartParam = (id)=>setMultipartBody(multipartBody.filter(p=>p.id!==id));
		const updateMultipartParam = (id, field, value)=>{ setMultipartBody(multipartBody.map(p=>p.id===id? {...p, [field]:value}: p)); };
		const handleMultipartFileChange = (id, file)=>{ setMultipartBody(multipartBody.map(p=>p.id===id? {...p, file:file, value:file? file.name: ''}: p)); };
		return (
				<Stack spacing={2}>
					<Typography variant="h6">请求 Body</Typography>
					<Box sx={{borderBottom:1, borderColor:'divider'}}>
						<Tabs value={bodyType} onChange={(e, newValue)=>setBodyType(newValue)}>
							<Tab label="None" value="none"/><Tab label="JSON" value="json"/><Tab label="Form" value="form"/>
							<Tab label="Multipart" value="multipart"/><Tab label="Binary" value="binary"/>
						</Tabs>
					</Box>
					{bodyType==='none' &&
							<Typography variant="body2" color="text.secondary" className="italic p-2">此请求类型通常不发送请求体。</Typography>}
					{bodyType==='json' &&
							<TextField multiline rows={8} fullWidth label="JSON Body" value={jsonBody} onChange={e=>setJsonBody(e.target.value)}
												 variant="outlined" className="font-mono"/>}
					{bodyType==='form' && <Stack spacing={2}>
						{formBody.map(param=>(<Stack key={param.id} direction="row" spacing={1} alignItems="center">
							<TextField size="small" label="Name" value={param.name} onChange={e=>updateFormParam(param.id, 'name', e.target.value)}
												 className="flex-1"/>
							<TextField size="small" label="Value" value={param.value} onChange={e=>updateFormParam(param.id, 'value', e.target.value)}
												 className="flex-1"/>
							<Button size="small" color="error" onClick={()=>removeFormParam(param.id)} startIcon={<Delete/>}>删除</Button>
						</Stack>))}
						<Box><Button variant="outlined" size="small" onClick={addFormParam} startIcon={<Add/>}>添加参数</Button></Box>
					</Stack>}
					{bodyType==='multipart' && <Stack spacing={2}>
						{multipartBody.map(param=>(<Paper key={param.id} variant="outlined" className="p-3">
							<Stack spacing={2}>
								<Stack direction="row" spacing={1} alignItems="center">
									<TextField size="small" label="Name" value={param.name}
														 onChange={e=>updateMultipartParam(param.id, 'name', e.target.value)} className="flex-1"/>
									<FormControl size="small" sx={{minWidth:100}}>
										<InputLabel>Type</InputLabel>
										<Select label="Type" value={param.type} onChange={e=>updateMultipartParam(param.id, 'type', e.target.value)}>
											<MenuItem value="text">Text</MenuItem><MenuItem value="file">File</MenuItem>
										</Select>
									</FormControl>
									<Button size="small" color="error" onClick={()=>removeMultipartParam(param.id)}
													startIcon={<Delete/>}>删除</Button>
								</Stack>
								{param.type==='text'?
								 (<TextField size="small" label="Value" value={param.value}
														 onChange={e=>updateMultipartParam(param.id, 'value', e.target.value)}/>):
								 (<Button component="label" variant="outlined" startIcon={<FileUpload/>}>
									 {param.file? param.file.name: '选择文件'}
									 <input type="file" hidden onChange={e=>handleMultipartFileChange(param.id, e.target.files[0])}/>
								 </Button>)
								}
							</Stack>
						</Paper>))}
						<Box><Button variant="outlined" size="small" onClick={addMultipartParam} startIcon={<Add/>}>添加参数</Button></Box>
					</Stack>}
					{bodyType==='binary' && <Box>
						<Button component="label" variant="contained" startIcon={<FileUpload/>}>
							{binaryFile? `已选择: ${binaryFile.name}`: '上传二进制文件'}
							<input type="file" hidden onChange={e=>setBinaryFile(e.target.files[0])}/>
						</Button>
					</Box>}
				</Stack>
		);
	}

	function ActionButtons({isLoading, handleSendRequest, handleCopyAsFetch, copyInfo}){
		return (
				<Stack direction="row" spacing={2} alignItems="stretch" className="pt-4">
					{/* *** BUG修复: 外层Box负责占据剩余空间, 内部Button填满Box *** */}
					<Box sx={{flexGrow:1}}>
						<Button
								variant="contained" color="primary" fullWidth onClick={handleSendRequest} disabled={isLoading}
								sx={{height:'100%'}}
								startIcon={isLoading? <CircularProgress size={20} color="inherit"/>: null}
						>
							{isLoading? '发送中...': '发送请求'}
						</Button>
					</Box>

					{/* *** BUG修复: 每个按钮都有自己的相对定位父级, 以便提示消息正确定位 *** */}
					<Box className="relative">
						<Button
								variant="outlined" color="secondary" onClick={()=>handleCopyAsFetch(false)} disabled={isLoading}
								startIcon={<ContentCopy/>}
								sx={{whiteSpace:'nowrap', height:'100%'}}
						>
							复制为 fetch (直连)
						</Button>
						{copyInfo.anchor==='direct' && (
								<span
										className="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap bg-gray-800 text-white text-xs rounded py-1 px-2">
									{copyInfo.message}
								</span>
						)}
					</Box>

					<Box className="relative">
						<Button
								variant="outlined" color="secondary" onClick={()=>handleCopyAsFetch(true)} disabled={isLoading}
								startIcon={<ContentCopy/>}
								sx={{whiteSpace:'nowrap', height:'100%'}}
						>
							复制为 fetch (代理)
						</Button>
						{copyInfo.anchor==='proxy' && (
								<span
										className="absolute -top-8 left-1/2 -translate-x-1/2 whitespace-nowrap bg-gray-800 text-white text-xs rounded py-1 px-2">
									{copyInfo.message}
								</span>
						)}
					</Box>
				</Stack>
		);
	}

	// 启动 React 应用
	createRoot(document.getElementById('root')).render(<App/>);
</script>
</head>

<body class="bg-gray-100">
<div id="root"></div>
</body>
</html>
